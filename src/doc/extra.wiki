== Using Docker containers ==
Alternatively, you may deploy a local cloud quickly by using Docker containers.

The Git repository contains the development files of these containers as well as
the versioned releases. Under most circumstances, it is recommended to use the
versioned
[https://forge.soa4d.org/plugins/scmgit/cgi-bin/gitweb.cgi?p=arrowhead-f/arrowhead-f.git;a=tree;f=3_Core+Systems/4_Local+deployment+guidence/V3.0_docker/releases;hb=HEAD
releases], but if you will be developing or testing the latest changes, use
[https://forge.soa4d.org/plugins/scmgit/cgi-bin/gitweb.cgi?p=arrowhead-f/arrowhead-f.git;a=tree;f=3_Core+Systems/4_Local+deployment+guidence/V3.0_docker/dev;hb=HEAD
dev].

Location:
<div style="overflow: auto">
<code>
    $ cd "arrowhead-f/3_Core Systems/4_Local deployment guidence/V3.0_docker"
</code>
</div>

Alternatively, you may download releases directly from the
[https://forge.soa4d.org/frs/?group_id=58 Forge website].

=== Releases ===
==== ahf-docker-17.10.4.0 ====
'''[https://forge.soa4d.org/frs/download.php/file/273/ahf-docker-17.10.4.0.zip ahf-docker-17.10.4.0.zip]'''
* First release.
* Features
** Core containers.
** SoapUI basic projects.
** One example (light control).
** One proxy (MQTT). But it might be removed in favor of Hasan's work on Transparency.
* Backlog
** Provide images that do not require building.
** Allow usage of external certificates / keys (including TSIG).
** Remove remaining .class files.
** Build SimpleServiceDiscovery from code instead of downloading a binary.
** Change download location of the core applications.

=== Quick usage ===
<!--Quick run-->
If you just want to get everything up and running quickly, just head to
<code>core</code> and use <code>docker-compose</code> to start up all the
necessary containers with the default settings.

'''Windows/Linux/Mac'''
<code>
    <b>>/$</b> cd '''core'''
    <b>>/$</b> docker-compose up
</code>

<!--Quick test-->
After the startup has completed (which might take a bit when it is your first
time running the containers) and log lines stop flashing by, you can test the
system by using the <code>soapui</code> container.

'''Windows/Linux/Mac'''
<code>
    <b>>/$</b> cd '''soapui'''
    <b>>/$</b> docker-compose up
</code>

This will run a series of tests which make calls on each of the core services to
determine if they are responding as expected. A fragment of a successful output
would be as follows:

<!--Successful test fragment-->
<div style="margin-right:300px;">
    <samp>
        <span style="color: darkcyan">soapui_1  |</span> -----------------------------
        <span style="color: darkcyan">soapui_1  |</span> Time Taken: 378ms
        <span style="color: darkcyan">soapui_1  |</span> Total TestSuites: 1
        <span style="color: darkcyan">soapui_1  |</span> Total TestCases: 5 (0 failed)
        <span style="color: darkcyan">soapui_1  |</span> Total TestSteps: 9
        <span style="color: darkcyan">soapui_1  |</span> Total Request Assertions: 15
        <span style="color: darkcyan">soapui_1  |</span> Total Failed Assertions: 0
        <span style="color: darkcyan">soapui_1  |</span> Total Exported Results: 0
        <span style="color: darkcyan">soapui_1  |</span> -----------------------------
    </samp>
</div>

For more details refer to the [[#Start containers with Docker Compose|Start
containers with Docker Compose]] tutorial.

=== Available containers ===
{| class="wikitable"
|-
! Directory !! Contents
|-
|
<code>
    core
    ├── bind
    ├── glassfish
    └── simpleservicediscovery
</code>
| style="vertical-align:top;" |

Contains the mandatory core services along with the necessary infrastructure,
namely, a server for DNS-SD ('''BIND'''), an application server for the web
services ('''Glassfish''') and the '''SimpleServiceDiscovery''' HTTP proxy for
the service registry (more information
[https://bitbucket.org/fedeselmer/simpleservicediscovery/ here]).

|-
|
<code>
    soapui
    └── projects
</code>
| style="vertical-align:top;" |

Contains a number of [https://www.soapui.org/ SoapUI] projects mapping the
available core services along with sample payloads. They also contain simple
test cases to verify basic functionality and which show a usage sample of the
services.

|-
|
<code>
    examples
    └── lightcontrol
</code>
| style="vertical-align:top;" |

Contains projects showing how to use the core services. These examples assume
that you are using the provided core containers, but you could make them work in
another local cloud without much effort.

|-
|
<code>
    proxies
    └── coap
</code>
| style="vertical-align:top;" |

Contains simple proxies for accessing the HTTP core web services using other
protocols, such as CoAP.

|}

=== Detailed usage ===
==== Core ====
The core containers can be used to set up your own local cloud. They are
provided as three separate images to provide flexibility of usage. These images
are: '''bind''' (DNS), '''glassfish''' (application server) and
'''simpleservicediscovery''' (service registry HTTP proxy).

===== Docker-compose =====
Providing flexibility and customization also means that there are more things
that can be configured. Since most users might want something that runs right
off the bat, a pre-configured set-up is provided in the form of a docker-compose
file. Docker-compose allows you to easily connect and configure a number of
containers, as well as maintain such configuration in an easy to understand YAML
file located at <code>core/docker-compose.yml</code>.

For details on the semantics used in this file, please refer to the
[https://docs.docker.com/compose/compose-file/ official documentation].

The file describes three services, one for each of the core containers. Each of
them is configured for the following:

* Connect to the other containers through a Docker network.
* Configure dependencies and behaviour through environment variables.
* Connect to shared volumes for TLS certificates and TSIG accessible through
other containers and the host.
* Expose the necessary ports for the host and remote clients to connect to the
containers.
* Configure names and aliases so other containers may find each other by name
(as long as they are on the same Docker network).

Edit this file as you need to match your requirements. In most scenarios the default configuration should work.

Then, to get the core containers up and running just execute the following command (assuming you are located at
<code>core</code>):

<code>
    $ docker-compose up
</code>

If you make changes that may require re-building the image, you can use the following command (when in doubt as to why
things seem to be failing, please try this before re-running the containers).

<code>
    $ docker-compose build
</code>

===== Standalone (docker run) =====

For more complex scenarios, you might be interested in running the containers
without docker-compose. In such case, you should keep in mind the following
dependencies, as well as the available environment variables used to configure
such dependencies.

{| class="wikitable"
|-
! Container !! Dependencies !! Environment variables
|-
|
'''bind'''
| style="vertical-align:top;" |
'''Dependencies''': None.

'''Exposes''': TSIG through volumes mounted on <code>/tsig</code> and
<code>/out</code>.

The TSIG is exposed in two locations <code>/tsig</code> and <code>/out</code>.
While you may use them as you prefer, the expected usage is that
<code>/tsig</code> is mounted as a named volume to be shared with other
containers, whereas <code>/out</code> is mounted as a bind volume which is
exposed on the host.

In those two directories, a file named tsig will be placed containing two lines.
First the name of the key and then the actual key (this is the format used by
core-utils, so it is subject to change).

| style="vertical-align:top;" |
<ul>

<li> '''<code>LOCK_OUT_DIR=<true|false></code>''': Whether <code>/out</code> and
its contents will have lax permissions ('''777''') or restrictive permissions
('''000''').

<li> '''<code>ALLOW_DOMAIN_UPDATE=<true|false></code>''': Whether others can
update the DNS. This can be used for others to register themselves, but it could
be insecure.

<li> '''<code>SERVER_DOMAIN</code>''': Domain used for publishing and browsing
in this service registry. Default is the domain of the container, or
'docker.ahf' if no domain is found.

<li> '''<code>SERVER_HOSTNAME</code>''': Hostname for the core services
published on DNS and DNS-SD. Default is the hostname of the container.

<li> '''<code>SERVER_ADDRESS</code>''': IP address for the core services
published on DNS. Default is the IP address obtained by using
LISTENING_INTERFACE_NAME below.

<li> '''<code>LISTENING_INTERFACE_NAME</code>''': Name of the interface from
which to get the network configuration for DNS. Currently assumes all services
will be in the same subnet as the DNS, which is the one given by this interface.

</ul>
|-
|
'''glassfish'''
| style="vertical-align:top;" |
'''Dependencies''':
<ul>
    <li> '''<code>/tsig</code>''': Reads the TSIG file with the key used by the
    name server.
</ul>

'''Exposes''': TLS certificates and keys through volumes mounted on
<code>/tls</code> and <code>/out</code>.

Specifically, it exposes the following files.
<ul> <li> '''cacerts.jks''': Trust store used by the server. The main relevant
entry has the ''dockerca'' alias as this Certificate Authority (CA) is used to
sign the server certificate and exposed so certificates may be generated for the
clients.

<li> '''ca.crt''':  Certificate for the CA mentioned above. Together with
<code>ca.key</code>, it may be used to sign new certificates.

<li> '''ca.key''': Key for the CA mentioned above. Together with
<code>ca.crt</code>, it may be used to sign new certificates.

<li> '''generate-signed-cert.sh''': Auxiliary script for generating signed
certificates given the previous files.

<li> '''tester.jks''': Pre-generated signed certificate for quick
development/testing. Provided in jks format for usage in Java applications. You
might need to convert it for non-Java usage. Future versions might provide other
formats. </ul>

These files are exposed in two locations <code>/tls</code> and
<code>/out</code>. While you may use them as you prefer, the expected usage is
that <code>/tls</code> is mounted as a named volume to be shared with other
containers, whereas <code>/out</code> is mounted as a bind volume which is
exposed on the host.

| style="vertical-align:top;" |

<ul>

<li> '''<code>LOCK_OUT_DIR=<true|false></code>''': Whether <code>/out</code> and
its contents will have lax permissions (777) or restrictive permissions (000).
Default: ''false'' (777).

<li> '''<code>DNS_SERVER</code>''': Location of the DNS server to be used. Under
most scenarios, you should use the same hostname you used for the bind container
or any of its aliases. Default: ''bind.docker.ahf''.

<li> '''<code>KEYSTORE_PASSWORD</code>''': Passphrase for the keystores used by
the Glassfish server. This includes the <code>cacerts.jks</code> trust store
exposed to other containers and to the host system. Therefore, containers
depending on <code>/tls</code>. Default: ''changeit''.

<li> '''<code>TESTER_KEYSTORE_PASSWORD</code>''': Passphrase for the
<code>tester.jks</code> quick-testing certificate generated on build. Default:
''changeit''.

<li> '''<code>REGISTER_WITH_DNS=<true|false></code>''': Whether the container
will try to register itself on the name server. If '''true''', it will attempt
to use the provided TSIG to update the DNS with its hostname and address. It
will fail silently if the operation is not allowed but will terminate if no TSIG
file is provided to indicate the user that the file is needed. Default:
''true''.

<li> '''<code>DO_DYNAMIC_DNS_UPDATE=<true|false></code>''': If
'''REGISTER_WITH_DNS''' is set to true, we can ensure our IP address is up to
date in the DNS server and update it when necessary. This is highly useful in
dynamic environments. Especially if we are using '''network=host'''.

<li> '''<code>IP_CHANGE_POLL_SECONDS</code>''': This allows us to control how
often we will check our current IP address against the address registered in the
DNS server when '''DO_DYNAMIC_DNS_UPDATE=true'''.  Default: ''5''.

<li> '''<code>GLASSFISH_ADMIN</code>''': Administrator username for the
Glassfish server. Default: ''admin''.

<li> '''<code>GLASSFISH_PASSWORD</code>''': Administrator passphrase for the
Glassfish server. Default: ''pass''.

<li> '''<code>SERVER_HOSTNAME</code>''': Hostname for the core services
published on DNS and DNS-SD. Default is the hostname of the container.

<li> '''<code>SERVER_DOMAIN</code>''': Domain the core services published on
DNS-SD. Default is the domain of the container, or 'docker.ahf' if no domain is
found.

<li> '''<code>SERVER_ADDRESS</code>''': IP address for the core services
published on DNS. Default is the IP address obtained by using
LISTENING_INTERFACE_NAME below.

<li> '''<code>LISTENING_INTERFACE_NAME</code>''': Name of the interface for
which to get the IP address to publish on DNS in case SERVER_ADDRESS is not
provided. Default is the IP address used as a main route for internet
(regardless of actual connectivity). </ul>

|-
|
'''simpleservicediscovery'''
||
'''Dependencies''':
<ul>

<li> '''<code>/tsig</code>''': Reads the TSIG file with the key used by the name
server.

<li> '''<code>/tls</code>''': Uses the CA files and the certificate generation
script provided by <code>core/glassfish</code>.

</ul>

'''Exposes''': Nothing.
| style="vertical-align:top;" |
<ul>
    
<li> '''<code>DNS_SERVER</code>''': Location of the DNS server to be used. Under
most scenarios, you should use the same hostname you used for the bind container
or any of its aliases. Default: ''bind.docker.ahf''.

<li> '''<code>ORCHESTRATION_URL</code>''': Used if this information is not found
on the service registry. Default:
''<nowiki>https://glassfish.docker.ahf:8181/orchestration/store''</nowiki>.

<li> '''<code>AUTHORISATION_URL</code>''': Used if this information is not found
on the service registry. Default:
''<nowiki>https://glassfish.docker.ahf:8181/authorisation''</nowiki>.

<li> '''<code>BROWSING_DOMAIN</code>''': Used for DNS-SD. For example, appended
to service names for service registry lookups. '''Fragile''': It might be
unclear whether it is assumed that you have prepended "srv.". The current
version assumes that you have '''not''' prepended "srv.". Future versions of the
container will take care of solving this for you. Default: ''docker.ahf''.

<li> '''<code>WAIT_FOR_TLS_READY=<true|false></code>''': Whether the container
will wait until the /tls/ready file is available. This file is created by
<code>core/glassfish</code> when initial setup has been completed and the server
is to start. Consider that the domain will take a few seconds to actually start
after this file has been created. Five to eight seconds will pass after the file
appears before this container continues its startup if this variable is true.
Default: ''true''.

<li> '''<code>WAIT_FOR_CA=<true|false></code>''': Whether the container will
wait until the <code>/tls/ca.key</code> file is available. Since this file is
necessary for this container, execution will stop is this variable is false and
the file is not found. The file, along with <code>ca.crt</code> is necessary for
generating the client certificate to be be used by the container. Default:
''true''.

<li> '''<code>WAIT_FOR_ORCH_STORE=<true|false></code>''': Whether the container
will wait until the orchestration store to respond to HTTP requests. This is
necessary in order to avoid race-time conditions between the containers.
Default: ''true''.

<li> '''<code>REGISTER_WITH_DNS=<true|false></code>''': Whether the container
will try to register itself on the name server. If '''true''', it will attempt
to use the provided TSIG to update the DNS with its hostname and address. It
will fail silently if the operation is not allowed but will terminate if no TSIG
file is provided to indicate the user that the file is needed. Default:
''true''.

<li> '''<code>DO_DYNAMIC_DNS_UPDATE=<true|false></code>''': If
'''REGISTER_WITH_DNS''' is set to true, we can ensure our IP address is up to
date in the DNS server and update it when necessary. This is highly useful in
dynamic environments. Especially if we are using '''network=host'''.

<li> '''<code>IP_CHANGE_POLL_SECONDS</code>''': This allows us to control how
often we will check our current IP address against the address registered in the
DNS server when '''DO_DYNAMIC_DNS_UPDATE=true'''.  Default: ''5''.

<li> '''<code>SERVER_HOSTNAME</code>''': Hostname for the core services
published on DNS and DNS-SD. Default is the hostname of the container.

<li> '''<code>SERVER_DOMAIN</code>''': Domain used for publishing and browsing
in this service registry. Default is the domain of the container, or
'docker.ahf' if no domain is found.

<li> '''<code>SERVER_ADDRESS</code>''': IP address for the core services
published on DNS. Default is the IP address obtained by using
LISTENING_INTERFACE_NAME below.

<li> '''<code>LISTENING_INTERFACE_NAME</code>''': Name of the interface for
which to get the IP address to publish on DNS in case SERVER_ADDRESS is not
provided. Default is the IP address used as a main route for internet
(regardless of actual connectivity).
    
</ul>
|}

In the table above, ''dependencies'' refer to volumes which contain necessary
files for the container. The easiest way is to use the containers as given and
share their named volumes. Otherwise, you may provide your own files and use
bind-mounted volumes, named volumes or data-only containers. These complex
scenarios are currently beyond the scope of this document, but tutorials might
eventually be written.

==== SoapUI ====
<!--The <code>docker/soapui</code> directory contains a number of
[https://www.soapui.org/ SoapUI] projects mapping the available core services
along with sample payloads. They also contain simple test cases to verify basic
functionality and which show a usage sample of the services.-->

 <!--soapui-->
 <!--├── projects-->
 <!--└── scripts-->

<!--The projects can be loaded directly into an instance of SoapUI or they may
be run using the provided container which will execute the included test cases
and provide a basic summary of the results.-->

==== Examples ====
The <code>docker/examples</code> directory contains projects showing how to use
the core services.

These examples assume that you are using the provided core containers, but you
could make them work in another local cloud without much effort.

<pre>
examples/
├── hello-ahf-java-pure
├── hello-ahf-nodejs
└── lightcontrol
</pre>

===== Java SE pure Hello Arrowhead example =====
Located under
[https://forge.soa4d.org/plugins/scmgit/cgi-bin/gitweb.cgi?p=arrowhead-f/arrowhead-f.git;a=tree;f=3_Core+Systems/4_Local+deployment+guidence/V3.0_docker/dev/examples/hello-ahf-java-pure;hb=HEAD
examples/hello-ahf-java-pure], this example shows a simple interaction between
the core services and a sample application. The primary means of interaction is
through HTTPS endpoints. For more information please refer to [[Java SE pure
Hello Arrowhead example]].

<!--Currently, there is only one example ('''lightcontrol''') which showcases
the following:-->
<!--* '''Using a Docker network''': Automatically connect to and discover the
core containers.-->
<!--* '''Generate a CA-signed certificate'''-->
<!--* '''Make direct calls to the core services'''-->
<!--** Register into the service registry-->
<!--** Use the authorisation service-->
<!--** Call the orchestration service-->
<!--* '''Expose push services'''-->


=== Getting Docker and Docker-Compose ===
==== Docker ====
In order to use the provided containers you need to have installed Docker. You
can find installation instructions in the
[https://docs.docker.com/engine/installation/ official website]. You can find
direct downloads for the following systems below:

<div style="float:left; margin:0; width:14em;">
* [https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe Windows]
</div>

<div style="float:left; margin:0;width:14em;">
* [https://download.docker.com/mac/stable/Docker.dmg Mac]
</div>

<div style="clear: both"></div>
* [https://get.docker.com/ Linux script]

For Linux, you may use the script provided above (it contains usage
instructions) or you might want to follow one of the following tutorials:

<div style="float:left; margin:0; width:14em;">
* [https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/#install-using-the-repository Ubuntu]
* [https://docs.docker.com/engine/installation/linux/docker-ce/debian/#install-using-the-repository Debian]
</div>
<div style="float:left; margin:0; width:14em;">
* [https://docs.docker.com/engine/installation/linux/docker-ce/centos/#install-using-the-repository CentOS]
* [https://docs.docker.com/engine/installation/linux/docker-ce/fedora/#install-using-the-repository Fedora]
</div>
<div style="float:left; margin:0; width:14em">
* [https://docs.docker.com/engine/installation/linux/docker-ce/binaries/ Binaries]
</div>
<div style="clear: both"></div>

If your Windows or Mac is on the older side, it might not be fully supported,
but you can still get things to work (with a few quirks) using the Docker
Toolbox:

* [https://docs.docker.com/toolbox/overview/ Alternative for older Windows/Mac systems]

==== Docker Compose ====
To get things quickly up and running, configuration files are provided with the
AHF Docker containers. These files are configurations used by Docker Compose to
link the necessary containers. Docker Compose is not essential but it is useful
because of these files.

===== Install in Windows and Mac =====
Docker Compose already comes with the Mac and Windows installations.

===== Install in Linux =====
In Linux, all you have to do is run the two following lines (for the latest
version, please refer to [https://github.com/docker/compose/releases the Docker
Compose GitHub page]).

<code>
    <b>$</b> curl \
        -L <nowiki>https://github.com/docker/compose/releases/download/1.16.1/docker-compose-$(uname -s)-$(uname -m)</nowiki> > \
        /usr/local/bin/docker-compose
    <b>$</b> chmod +x /usr/local/bin/docker-compose
</code>

===== Bash auto-complete =====
Additionally, if you would like to have useful command-line completion in your
bash terminal in Linux, you may run the following line:

<code>
    <b>$</b> sudo curl \
        -L <nowiki>https://raw.githubusercontent.com/docker/compose/1.16.1/contrib/completion/bash/docker-compose</nowiki> \
        -o /etc/bash_completion.d/docker-compose
</code>

For other operating systems or terminals, please refer to the
[https://docs.docker.com/compose/completion/ official site].

=== Tutorials  ===
==== From zero to up and running (Docker Compose) ====
Alright no, we will not start from zero. You have to install Docker and Docker
Compose first.

===== Get latest ahf-docker =====
Start up a terminal, go to your favorite workspace and download the latest
ahf-docker release. Then unzip it so that we can get started.

'''Linux'''
<code>
    <b>$</b> <nowiki>wget --no-check-certificate https://forge.soa4d.org/frs/download.php/file/273/ahf-docker-17.10.4.0.zip</nowiki>
    <b>$</b> unzip ahf-docker-*.zip
    <b>$</b> cd ahf-docker-*/
    <b>$</b> ls
</code>

'''Windows'''
<code>
    <b>></b> set ahf-docker-ver=17.10.4.0
    <b>></b> <nowiki>powershell -command "(new-object System.Net.WebClient).DownloadFile('https://forge.soa4d.org/frs/download.php/file/273/ahf-docker-%ahf-docker-ver%', '.\ahf-docker-%ahf-docker-ver%.zip')"</nowiki>
    <b>></b> powershell -command "& { Add-Type -A 'System.IO.Compression.FileSystem'; [IO.Compression.ZipFile]::ExtractToDirectory('ahf-docker-%ahf-docker-ver%.zip', '.'); }"
    <b>></b> cd ahf-docker-%ahf-docker-ver%
    <b>></b> dir
</code>

The above should leave you in the right directory and list it. The last line of
output should look similar to the following.

<samp>
    <span style="color: darkcyan; font-weight: bold;">core</span>  <span style="color: darkcyan; font-weight: bold;">examples</span>  <span style="color: darkcyan; font-weight: bold;">proxies</span>  README.md  README.wiki  <span style="color: darkcyan; font-weight: bold;">soapui</span>
</samp>

Before we continue, let us store the current path so that we may copy-paste
freely (lowercase for readability).

'''Linux'''
<code>
    <b>$</b> echo "export AHF_DOCKER_PATH=$(pwd)" >> $HOME/.bashrc && source $HOME/.bashrc
</code>

'''Windows'''
<code>
    <b>></b> setx AHF_DOCKER_PATH %cd% && refreshenv
</code>

===== Start containers with Docker Compose =====
Now, use Docker Compose to start the core containers.

'''Linux'''
<code>
    <b>$</b> cd "$AHF_DOCKER_PATH"/'''core'''
    <b>$</b> docker-compose up --build
</code>

'''Windows'''
<code>
    <b>></b> cd "%AHF_DOCKER_PATH%"/'''core'''
    <b>></b> docker-compose up --build
</code>

With this, the <code>docker-compose.yml</code> file will be parsed and the
necessary containers will be (re-)built and started.

This might take a while, depending on processing power, memory type and network
speed. This will specially more time during the first run. Docker uses a local
cache, so future builds will be faster.

By default, the output of each container will be displayed, tagged with the name
of the corresponding container. This means that you can get a good idea about
what is happening on each container on run-time. During start-up this will let
you know when everything is ready.

For Windows you will probably be asked to share the C:\ drive. This allows
inter-container file sharing through volumes.

With so many output lines going by and some pauses in-between, it might not be
immediately obvious when everything is ready. To be certain, look for the lines
below:

<samp>
    <span style="color: darkolivegreen">glassfish_1     |</span> [#|2017-10-14T15:11:43.884+0000|INFO|glassfish3.1.2|javax.enterprise.system.core.com.sun.enterprise.v3.server|_ThreadID=1;_ThreadName=main;|
    GlassFish Server Open Source Edition 3.1.2.2 (5) startup time : Felix (1,843ms), startup services(19,386ms), total(21,229ms)|#]
    <span style="color: darkolivegreen">glassfish_1     |</span>
    <span style="color: darkolivegreen">glassfish_1     |</span> [#|2017-10-14T15:11:44.455+0000|INFO|glassfish3.1.2|javax.enterprise.system.jmx.org.glassfish.admin.mbeanserver|_ThreadID=76;_ThreadName=Thread-44;|
    JMX005: JMXStartupService had Started JMXConnector on JMXService URL service:jmx:rmi://glassfish.docker.ahf:8686/jndi/rmi://glassfish.docker.ahf:8686/jmxrmi|#]
</samp>

The containers will keep running and the current versions of the core services
throw exceptions every now and then, so those lines might get lost pretty
quickly. Another way to know if everything is up and running is to head to the
Management Tool.

<code>
    http://127.0.0.1:8080/managementtool/
</code>

If it loads, then you may assume everything works well. You can do further
testing inside the Management Tool by using the default username
<code>admin</code> and password <code>pass</code>. We will see later how to
change these.

To have further evidence that everything works, you may run the provided light
test-suite by opening another terminal, heading to the ahf-docker folder and
running the <code>soapui</code> container.

'''Linux'''
<code>
    <b>$</b> cd "$AHF_DOCKER_PATH"/'''soapui'''
    <b>$</b> docker-compose up --build
</code>

'''Windows'''
<code>
    <b>></b> cd "%AHF_DOCKER_PATH%"/'''soapui'''
    <b>></b> docker-compose up --build
</code>

Again, please give the containers some time to build if this is your first time
running them. For these containers, the lengthiest part is downloading SoapUI
into the container (remember that nothing is installed outside of the
container). Therefore, future runs will be very quick.

As opposed to the core containers, this one will just run a series of tests and
exit. It will print a summary of each of the tests ran. A sample of a test run
is as follows:

[[File:Selection_019.png|right|thumb|250px|Sample SoapUI results]]

<div style="margin-right:300px;">
<samp>
    <span style="color: darkcyan">soapui_1  |</span> -----------------------------
    <span style="color: darkcyan">soapui_1  |</span> Time Taken: 378ms
    <span style="color: darkcyan">soapui_1  |</span> Total TestSuites: 1
    <span style="color: darkcyan">soapui_1  |</span> Total TestCases: 5 (0 failed)
    <span style="color: darkcyan">soapui_1  |</span> Total TestSteps: 9
    <span style="color: darkcyan">soapui_1  |</span> Total Request Assertions: 15
    <span style="color: darkcyan">soapui_1  |</span> Total Failed Assertions: 0
    <span style="color: darkcyan">soapui_1  |</span> Total Exported Results: 0
    <span style="color: darkcyan">soapui_1  |</span> -----------------------------
</samp>
</div>

What you want is to always see <code>'''(0 failed)'''</code>. This means that
from all the services tested in that particular case, none presented any obvious
failures. These tests are far from having a 100% coverage, but they provide
enough indication to assume that the services are responding as expected under
regular circumstances.

Alright! So everything seems to be up and running correctly. It is now time for
you to play around with the containers by making calls from an external program
(located in your own computer). Please head to [[#Using SoapUI with the core
services|Using SoapUI with the core services]].

<gallery>
    Image:Selection_019.png
    Image:Selection_018.png
    Image:Selection_017.png
    Image:Selection_016.png
    Image:Selection_015.png
    Image:Selection_014.png
    Image:Selection_013.png
    Image:Selection_012.png
    Image:Selection_011.png
    Image:Selection_010.png
    Image:Selection_009.png
    Image:Selection_008.png
    Image:Selection_007.png
    Image:Selection_006.png
</gallery>

==== Using SoapUI with the core services ====
While you can run the command below on the <code>soapui</code> directory to run
a quick battery of tests on the core containers, you can also use the projects
provided there directly on SoapUI.

'''Linux'''
<div style="overflow: auto">
<code>
    <b>$</b> cd "$AHF_DOCKER_PATH"/'''soapui'''
    <b>$</b> docker-compose up --build
</code>
</div>

'''Windows'''
<div style="overflow: auto">
<code>
    <b>></b> cd "%AHF_DOCKER_PATH%"/'''soapui'''
    <b>></b> docker-compose up --build
</code>
</div>

SoapUI is a tool which lets you interact quickly with web services. Endpoints
and resources can be mapped and requests can be saved for quick testing. This
tool also provides the possibility of exporting to Postman or Swagger. For more
information, please refer to the [https://www.soapui.org/ official SoapUI
website].

To open these projects, you must first install SoapUI in your computer. Their
official website provides installation wizards:

* [https://www.soapui.org/getting-started/installing-soapui/installing-on-windows.html SoapUI Windows]
* [https://www.soapui.org/getting-started/installing-soapui/installing-on-mac.html SoapUI Mac]
* [https://www.soapui.org/getting-started/installing-soapui/installing-on-linux-or-unix.html SoapUI Linux]

[[File:2017-10-17_16_12_26-SoapUI_5.3.0.png|right|thumb|250px|Import project in
SoapUI]]

Once installed, open SoapUI and select <u>F</u>ile/<u>I</u>mport Project,
navigate to <code>ahf-docker/soapui/projects</code> and open the one you wish to
use. You can open multiple, but you will have to repeat the process for each
one.

As an example, let's PUT an authorisation request on the
/authorisation-control/authorisation REST resource.

First, we will need a client certificate. Fortunately, the
<code>core/glassfish</code> container already generated one for us. It is
located in <code>core/tls</code> (you will '''not''' see this folder if you have
never started the core containers). We could also generate others as we are also
provided with the necessary Certificate Authority files, but for now we will
not.

[[File:2017-10-17_16_09_02-SoapUI_Preferences.png|right|thumb|250px|Preferences
for using client certificate]]

To tell SoapUI to use our client certificate, go to <u>F</u>ile/Preferences/SSL
Settings and fill in the following:

* '''KeyStore''' with the path to the .jks file (default: ''tester.jks'').
* '''KeyStore Password''' with the password (default: ''changeit'').
* '''Client Authentication''' must be enabled for SoapUI to send the client
certificate.

Press '''OK''' when you are done.

[[File:2017-10-17_16_14_23-SoapUI_5.3.0.png|right|thumb|250px|Request view for
''PUT authorisation request'']]

Now open up the authorisation-control project and under the endpoint (with the
two arrows [[File:2017-10-17 16_18_21-SoapUI 5.3.0.png]]), navigate down as
follows:
<div style="overflow: auto">
<code>
  <nowiki>https://127.0.0.1:8181</nowiki>
    └──Authorisation-control [/authorisation-control/authorisation]
        └──PUT authorization request
            └──put-authorisation-request
</code>
</div>

This is a sample authorisation request which will tell us if
<code>distinguishedName</code> is authorised to use the given
<code>serviceName</code> of <code>serviceType</code>. This information is taken
from the payload which you can see and edit in your SoapUI instance. To send the
request, press the green arrowhead [[File:2017-10-17 16_15_01-SoapUI 5.3.0.png]]
and you should get a response similar to the following:

<div style="overflow: auto">
<code>
 <authorisationResponse>
     <authorised>false</authorised>
     <request>
         <distinguishedName>C=US,ST=California,L=Santa Clara,O=Oracle Corporation,OU=GlassFish,CN=glassfish.docker.ahf</distinguishedName>
         <serviceName>orchestration-store</serviceName>
         <serviceType>_orch-s-ws-https._tcp</serviceType>
     </request>
 </authorisationResponse>
</code>
</div>

If you do not see a response and notice that the status bar at the bottom of the
request window says something along the lines of an SSL handshake error:

<div style="overflow: auto">
<pre>
Error getting rseponse: jax.net.ssl.SSLHandshakeException: Remote host closed
connection during handshake
</pre>
</div>

Please try again after closing and reopening SoapUI. This issue happens when the
certificate has been recreated and SoapUI still has the previous one (with the
same name) loaded in memory. (The certificate is recreated each time you
re-build the containers.)

Everything should be working properly now, feel free to play around.

Please consider that some core services do not return responses, only response
codes. For example, if you set a configuration as active using
orchestration/active-config/set-active-configuration, you will not see a
response if the operation was successful. On the other hand, if the operation
failed because the configuration does not exist, you will get a '''404 Not
Found''' error with a generic HTML page. Either way, here the response code is
what is important, and to see it, you should press "Raw" on the response tab.

If at any point you wonder if you are missing any steps or information on your
payload, feel free to review the corresponding TestSuite found directly under
the top of the project. This also helps if you want to know what response code
to expect as most of them make the corresponding assertions.

<gallery>
    Image:2017-10-17 16_08_03-SoapUI 5.3.0.png
    Image:2017-10-17 16_09_02-SoapUI Preferences.png
    Image:2017-10-17 16_11_35-SoapUI 5.3.0.png
    Image:2017-10-17 16_11_55-ahf-docker - [C__Users_ferram-local_ws_ahf-docker] - [ahf-docker] - ..._README.w.png
    Image:2017-10-17 16_12_13-SoapUI 5.3.0.png
    Image:2017-10-17 16_12_26-SoapUI 5.3.0.png
    Image:2017-10-17 16_13_17-Select soapUI Project File.png
    Image:2017-10-17 16_13_49-Select soapUI Project File.png
    Image:2017-10-17 16_14_23-SoapUI 5.3.0.png
    Image:2017-10-17 16_14_50-SoapUI 5.3.0.png
    Image:2017-10-17 16_15_25-SoapUI 5.3.0.png
    Image:2017-10-17 16_15_55-SoapUI 5.3.0.png
    Image:2017-10-17 16_16_29-SoapUI 5.3.0.png
</gallery>


Up to [[Core systems & services]]
